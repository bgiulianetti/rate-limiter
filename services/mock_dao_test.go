// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package services

import (
	"rate-limiter/dao"
	"rate-limiter/domain"
	"sync"
)

// Ensure, that ContainerMock does implement dao.Container.
// If this is not the case, regenerate this file with moq.
var _ dao.Container = &ContainerMock{}

// ContainerMock is a mock implementation of dao.Container.
//
//	func TestSomethingThatUsesContainer(t *testing.T) {
//
//		// make and configure a mocked dao.Container
//		mockedContainer := &ContainerMock{
//			GetNotificationByTypeAndUserFunc: func(s1 string, s2 string) (*domain.Notification, error) {
//				panic("mock out the GetNotificationByTypeAndUser method")
//			},
//			GetNotificationsFunc: func() (map[string]map[string]*domain.Notification, error) {
//				panic("mock out the GetNotifications method")
//			},
//			GetNotificationsByTypeFunc: func(s string) (map[string]*domain.Notification, error) {
//				panic("mock out the GetNotificationsByType method")
//			},
//			GetRuleByTypeFunc: func(s string) (*domain.RateLimitRule, error) {
//				panic("mock out the GetRuleByType method")
//			},
//			GetRulesFunc: func() (map[string]*domain.RateLimitRule, error) {
//				panic("mock out the GetRules method")
//			},
//			IncrementNotificationCountFunc: func(s1 string, s2 string) error {
//				panic("mock out the IncrementNotificationCount method")
//			},
//			ResetNotificationCountFunc: func(s1 string, s2 string) error {
//				panic("mock out the ResetNotificationCount method")
//			},
//		}
//
//		// use mockedContainer in code that requires dao.Container
//		// and then make assertions.
//
//	}
type ContainerMock struct {
	// GetNotificationByTypeAndUserFunc mocks the GetNotificationByTypeAndUser method.
	GetNotificationByTypeAndUserFunc func(s1 string, s2 string) (*domain.Notification, error)

	// GetNotificationsFunc mocks the GetNotifications method.
	GetNotificationsFunc func() (map[string]map[string]*domain.Notification, error)

	// GetNotificationsByTypeFunc mocks the GetNotificationsByType method.
	GetNotificationsByTypeFunc func(s string) (map[string]*domain.Notification, error)

	// GetRuleByTypeFunc mocks the GetRuleByType method.
	GetRuleByTypeFunc func(s string) (*domain.RateLimitRule, error)

	// GetRulesFunc mocks the GetRules method.
	GetRulesFunc func() (map[string]*domain.RateLimitRule, error)

	// IncrementNotificationCountFunc mocks the IncrementNotificationCount method.
	IncrementNotificationCountFunc func(s1 string, s2 string) error

	// ResetNotificationCountFunc mocks the ResetNotificationCount method.
	ResetNotificationCountFunc func(s1 string, s2 string) error

	// calls tracks calls to the methods.
	calls struct {
		// GetNotificationByTypeAndUser holds details about calls to the GetNotificationByTypeAndUser method.
		GetNotificationByTypeAndUser []struct {
			// S1 is the s1 argument value.
			S1 string
			// S2 is the s2 argument value.
			S2 string
		}
		// GetNotifications holds details about calls to the GetNotifications method.
		GetNotifications []struct {
		}
		// GetNotificationsByType holds details about calls to the GetNotificationsByType method.
		GetNotificationsByType []struct {
			// S is the s argument value.
			S string
		}
		// GetRuleByType holds details about calls to the GetRuleByType method.
		GetRuleByType []struct {
			// S is the s argument value.
			S string
		}
		// GetRules holds details about calls to the GetRules method.
		GetRules []struct {
		}
		// IncrementNotificationCount holds details about calls to the IncrementNotificationCount method.
		IncrementNotificationCount []struct {
			// S1 is the s1 argument value.
			S1 string
			// S2 is the s2 argument value.
			S2 string
		}
		// ResetNotificationCount holds details about calls to the ResetNotificationCount method.
		ResetNotificationCount []struct {
			// S1 is the s1 argument value.
			S1 string
			// S2 is the s2 argument value.
			S2 string
		}
	}
	lockGetNotificationByTypeAndUser sync.RWMutex
	lockGetNotifications             sync.RWMutex
	lockGetNotificationsByType       sync.RWMutex
	lockGetRuleByType                sync.RWMutex
	lockGetRules                     sync.RWMutex
	lockIncrementNotificationCount   sync.RWMutex
	lockResetNotificationCount       sync.RWMutex
}

// GetNotificationByTypeAndUser calls GetNotificationByTypeAndUserFunc.
func (mock *ContainerMock) GetNotificationByTypeAndUser(s1 string, s2 string) (*domain.Notification, error) {
	if mock.GetNotificationByTypeAndUserFunc == nil {
		panic("ContainerMock.GetNotificationByTypeAndUserFunc: method is nil but Container.GetNotificationByTypeAndUser was just called")
	}
	callInfo := struct {
		S1 string
		S2 string
	}{
		S1: s1,
		S2: s2,
	}
	mock.lockGetNotificationByTypeAndUser.Lock()
	mock.calls.GetNotificationByTypeAndUser = append(mock.calls.GetNotificationByTypeAndUser, callInfo)
	mock.lockGetNotificationByTypeAndUser.Unlock()
	return mock.GetNotificationByTypeAndUserFunc(s1, s2)
}

// GetNotificationByTypeAndUserCalls gets all the calls that were made to GetNotificationByTypeAndUser.
// Check the length with:
//
//	len(mockedContainer.GetNotificationByTypeAndUserCalls())
func (mock *ContainerMock) GetNotificationByTypeAndUserCalls() []struct {
	S1 string
	S2 string
} {
	var calls []struct {
		S1 string
		S2 string
	}
	mock.lockGetNotificationByTypeAndUser.RLock()
	calls = mock.calls.GetNotificationByTypeAndUser
	mock.lockGetNotificationByTypeAndUser.RUnlock()
	return calls
}

// GetNotifications calls GetNotificationsFunc.
func (mock *ContainerMock) GetNotifications() (map[string]map[string]*domain.Notification, error) {
	if mock.GetNotificationsFunc == nil {
		panic("ContainerMock.GetNotificationsFunc: method is nil but Container.GetNotifications was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetNotifications.Lock()
	mock.calls.GetNotifications = append(mock.calls.GetNotifications, callInfo)
	mock.lockGetNotifications.Unlock()
	return mock.GetNotificationsFunc()
}

// GetNotificationsCalls gets all the calls that were made to GetNotifications.
// Check the length with:
//
//	len(mockedContainer.GetNotificationsCalls())
func (mock *ContainerMock) GetNotificationsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetNotifications.RLock()
	calls = mock.calls.GetNotifications
	mock.lockGetNotifications.RUnlock()
	return calls
}

// GetNotificationsByType calls GetNotificationsByTypeFunc.
func (mock *ContainerMock) GetNotificationsByType(s string) (map[string]*domain.Notification, error) {
	if mock.GetNotificationsByTypeFunc == nil {
		panic("ContainerMock.GetNotificationsByTypeFunc: method is nil but Container.GetNotificationsByType was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockGetNotificationsByType.Lock()
	mock.calls.GetNotificationsByType = append(mock.calls.GetNotificationsByType, callInfo)
	mock.lockGetNotificationsByType.Unlock()
	return mock.GetNotificationsByTypeFunc(s)
}

// GetNotificationsByTypeCalls gets all the calls that were made to GetNotificationsByType.
// Check the length with:
//
//	len(mockedContainer.GetNotificationsByTypeCalls())
func (mock *ContainerMock) GetNotificationsByTypeCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockGetNotificationsByType.RLock()
	calls = mock.calls.GetNotificationsByType
	mock.lockGetNotificationsByType.RUnlock()
	return calls
}

// GetRuleByType calls GetRuleByTypeFunc.
func (mock *ContainerMock) GetRuleByType(s string) (*domain.RateLimitRule, error) {
	if mock.GetRuleByTypeFunc == nil {
		panic("ContainerMock.GetRuleByTypeFunc: method is nil but Container.GetRuleByType was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockGetRuleByType.Lock()
	mock.calls.GetRuleByType = append(mock.calls.GetRuleByType, callInfo)
	mock.lockGetRuleByType.Unlock()
	return mock.GetRuleByTypeFunc(s)
}

// GetRuleByTypeCalls gets all the calls that were made to GetRuleByType.
// Check the length with:
//
//	len(mockedContainer.GetRuleByTypeCalls())
func (mock *ContainerMock) GetRuleByTypeCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockGetRuleByType.RLock()
	calls = mock.calls.GetRuleByType
	mock.lockGetRuleByType.RUnlock()
	return calls
}

// GetRules calls GetRulesFunc.
func (mock *ContainerMock) GetRules() (map[string]*domain.RateLimitRule, error) {
	if mock.GetRulesFunc == nil {
		panic("ContainerMock.GetRulesFunc: method is nil but Container.GetRules was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetRules.Lock()
	mock.calls.GetRules = append(mock.calls.GetRules, callInfo)
	mock.lockGetRules.Unlock()
	return mock.GetRulesFunc()
}

// GetRulesCalls gets all the calls that were made to GetRules.
// Check the length with:
//
//	len(mockedContainer.GetRulesCalls())
func (mock *ContainerMock) GetRulesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetRules.RLock()
	calls = mock.calls.GetRules
	mock.lockGetRules.RUnlock()
	return calls
}

// IncrementNotificationCount calls IncrementNotificationCountFunc.
func (mock *ContainerMock) IncrementNotificationCount(s1 string, s2 string) error {
	if mock.IncrementNotificationCountFunc == nil {
		panic("ContainerMock.IncrementNotificationCountFunc: method is nil but Container.IncrementNotificationCount was just called")
	}
	callInfo := struct {
		S1 string
		S2 string
	}{
		S1: s1,
		S2: s2,
	}
	mock.lockIncrementNotificationCount.Lock()
	mock.calls.IncrementNotificationCount = append(mock.calls.IncrementNotificationCount, callInfo)
	mock.lockIncrementNotificationCount.Unlock()
	return mock.IncrementNotificationCountFunc(s1, s2)
}

// IncrementNotificationCountCalls gets all the calls that were made to IncrementNotificationCount.
// Check the length with:
//
//	len(mockedContainer.IncrementNotificationCountCalls())
func (mock *ContainerMock) IncrementNotificationCountCalls() []struct {
	S1 string
	S2 string
} {
	var calls []struct {
		S1 string
		S2 string
	}
	mock.lockIncrementNotificationCount.RLock()
	calls = mock.calls.IncrementNotificationCount
	mock.lockIncrementNotificationCount.RUnlock()
	return calls
}

// ResetNotificationCount calls ResetNotificationCountFunc.
func (mock *ContainerMock) ResetNotificationCount(s1 string, s2 string) error {
	if mock.ResetNotificationCountFunc == nil {
		panic("ContainerMock.ResetNotificationCountFunc: method is nil but Container.ResetNotificationCount was just called")
	}
	callInfo := struct {
		S1 string
		S2 string
	}{
		S1: s1,
		S2: s2,
	}
	mock.lockResetNotificationCount.Lock()
	mock.calls.ResetNotificationCount = append(mock.calls.ResetNotificationCount, callInfo)
	mock.lockResetNotificationCount.Unlock()
	return mock.ResetNotificationCountFunc(s1, s2)
}

// ResetNotificationCountCalls gets all the calls that were made to ResetNotificationCount.
// Check the length with:
//
//	len(mockedContainer.ResetNotificationCountCalls())
func (mock *ContainerMock) ResetNotificationCountCalls() []struct {
	S1 string
	S2 string
} {
	var calls []struct {
		S1 string
		S2 string
	}
	mock.lockResetNotificationCount.RLock()
	calls = mock.calls.ResetNotificationCount
	mock.lockResetNotificationCount.RUnlock()
	return calls
}
